<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可重複使用的拖曳面板</title>
    <!-- 引入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 確保所有元素使用 box-sizing: border-box */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* 設定整個頁面的字體和背景 */
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200;
        }

        .gutter {
            flex: 0 0 24px;
            background-color: #1a202c;
            cursor: ew-resize;
            user-select: none;
            @apply h-full transition-colors duration-200;
        }

        .gutter:hover {
            @apply bg-gray-600;
        }

        .resizable-panel {
            @apply p-6 flex items-center justify-center transition-all duration-100 ease-linear;
        }
    </style>
</head>
<body class="p-8">

    <div class="h-full min-h-[500px] flex flex-col items-center justify-center p-4">
        <h1 class="text-4xl font-bold mb-6 text-center">可重複使用的拖曳面板</h1>

        <!-- 第一個可拖曳容器 -->
        <div id="container1" class="resizable-container flex w-full h-[60vh] max-w-5xl overflow-hidden rounded-xl shadow-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 mb-8">
            <!-- 左側面板 -->
            <div class="resizable-panel bg-gray-50 dark:bg-gray-950" style="flex: 1 0 30%;">
                <p class="text-center text-sm sm:text-base text-gray-600 dark:text-gray-400">這是左側面板。</p>
            </div>
            <!-- 拖曳條 -->
            <div class="gutter"></div>
            <!-- 右側面板 -->
            <div class="resizable-panel bg-gray-100 dark:bg-gray-800" style="flex: 1 0 70%;">
                <p class="text-center text-sm sm:text-base text-gray-600 dark:text-gray-400">這是右側面板。它會自動適應剩餘空間。</p>
            </div>
        </div>

        <!-- 第二個可拖曳容器 (包含兩個拖曳條) -->
        <div id="container2" class="resizable-container flex w-full h-[60vh] max-w-5xl overflow-hidden rounded-xl shadow-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
            <!-- 第一個面板 -->
            <div class="resizable-panel bg-gray-50 dark:bg-gray-950" style="flex: 1 0 20%;">
                <p class="text-center text-sm sm:text-base text-gray-600 dark:text-gray-400">這是第一個面板。</p>
            </div>
            <!-- 第一個拖曳條 -->
            <div class="gutter"></div>
            <!-- 第二個面板 -->
            <div class="resizable-panel bg-gray-100 dark:bg-gray-800" style="flex: 1 0 50%;">
                <p class="text-center text-sm sm:text-base text-gray-600 dark:text-gray-400">這是第二個面板。</p>
            </div>
            <!-- 第二個拖曳條 -->
            <div class="gutter"></div>
            <!-- 第三個面板 -->
            <div class="resizable-panel bg-gray-50 dark:bg-gray-950" style="flex: 1 0 30%;">
                <p class="text-center text-sm sm:text-base text-gray-600 dark:text-gray-400">這是第三個面板。</p>
            </div>
        </div>
    </div>

    <script>
        /**
         * 啟用可拖曳調整大小的功能。
         *
         * @param {HTMLElement} container - 包含可拖曳面板的容器元素。
         */
        function makeResizable(container) {
            // 找到容器內所有的分隔線 (gutter)
            const gutters = container.querySelectorAll('.gutter');

            // 針對每一條分隔線，附加滑鼠事件
            gutters.forEach(gutter => {
                let isDragging = false;
                let leftPanel, rightPanel;
                let initialLeftWidth, initialRightWidth, initialX;

                // 監聽滑鼠在拖曳條上按下的事件
                gutter.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    e.preventDefault();

                    // 取得相鄰的面板
                    leftPanel = gutter.previousElementSibling;
                    rightPanel = gutter.nextElementSibling;
                    
                    // 儲存初始狀態
                    initialLeftWidth = leftPanel.offsetWidth;
                    initialRightWidth = rightPanel.offsetWidth;
                    initialX = e.clientX;
                });

                // 監聽滑鼠在整個文件上移動的事件
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const deltaX = e.clientX - initialX; // 計算滑鼠移動的距離
                    
                    const newLeftWidth = initialLeftWidth + deltaX;
                    const newRightWidth = initialRightWidth - deltaX;

                    // 確保面板不會縮小到太小
                    const minWidth = 100; // 最小寬度 (以 px 為單位)

                    if (newLeftWidth > minWidth && newRightWidth > minWidth) {
                        leftPanel.style.flexBasis = `${newLeftWidth}px`;
                        rightPanel.style.flexBasis = `${newRightWidth}px`;
                    }
                });

                // 監聽滑鼠放開的事件
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            });
        }

        // 頁面載入後，對所有標有 'resizable-container' 的容器啟用功能
        window.addEventListener('load', () => {
            const containers = document.querySelectorAll('.resizable-container');
            containers.forEach(container => {
                makeResizable(container);
            });
        });

    </script>
</body>
</html>

